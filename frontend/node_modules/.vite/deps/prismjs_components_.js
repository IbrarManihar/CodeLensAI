import {
  require_components
} from "./chunk-EMA7R3ZZ.js";
import {
  __commonJS,
  __require
} from "./chunk-2TUXWMP5.js";

// node_modules/prismjs/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/prismjs/dependencies.js"(exports, module) {
    "use strict";
    var getLoader = /* @__PURE__ */ function() {
      var noop = function() {
      };
      function forEach(value, callbackFn) {
        if (Array.isArray(value)) {
          value.forEach(callbackFn);
        } else if (value != null) {
          callbackFn(value, 0);
        }
      }
      function toSet(array) {
        var set = {};
        for (var i = 0, l = array.length; i < l; i++) {
          set[array[i]] = true;
        }
        return set;
      }
      function createEntryMap(components) {
        var map = {};
        for (var categoryName in components) {
          var category = components[categoryName];
          for (var id in category) {
            if (id != "meta") {
              var entry = category[id];
              map[id] = typeof entry == "string" ? { title: entry } : entry;
            }
          }
        }
        return map;
      }
      function createDependencyResolver(entryMap) {
        var map = {};
        var _stackArray = [];
        function addToMap(id, stack) {
          if (id in map) {
            return;
          }
          stack.push(id);
          var firstIndex = stack.indexOf(id);
          if (firstIndex < stack.length - 1) {
            throw new Error("Circular dependency: " + stack.slice(firstIndex).join(" -> "));
          }
          var dependencies = {};
          var entry = entryMap[id];
          if (entry) {
            let handleDirectDependency = function(depId) {
              if (!(depId in entryMap)) {
                throw new Error(id + " depends on an unknown component " + depId);
              }
              if (depId in dependencies) {
                return;
              }
              addToMap(depId, stack);
              dependencies[depId] = true;
              for (var transitiveDepId in map[depId]) {
                dependencies[transitiveDepId] = true;
              }
            };
            forEach(entry.require, handleDirectDependency);
            forEach(entry.optional, handleDirectDependency);
            forEach(entry.modify, handleDirectDependency);
          }
          map[id] = dependencies;
          stack.pop();
        }
        return function(id) {
          var deps = map[id];
          if (!deps) {
            addToMap(id, _stackArray);
            deps = map[id];
          }
          return deps;
        };
      }
      function createAliasResolver(entryMap) {
        var map;
        return function(idOrAlias) {
          if (idOrAlias in entryMap) {
            return idOrAlias;
          } else {
            if (!map) {
              map = {};
              for (var id in entryMap) {
                var entry = entryMap[id];
                forEach(entry && entry.alias, function(alias) {
                  if (alias in map) {
                    throw new Error(alias + " cannot be alias for both " + id + " and " + map[alias]);
                  }
                  if (alias in entryMap) {
                    throw new Error(alias + " cannot be alias of " + id + " because it is a component.");
                  }
                  map[alias] = id;
                });
              }
            }
            return map[idOrAlias] || idOrAlias;
          }
        };
      }
      function loadComponentsInOrder(dependencyResolver, ids, loadComponent, chainer) {
        var series = chainer ? chainer.series : void 0;
        var parallel = chainer ? chainer.parallel : noop;
        var cache = {};
        var ends = {};
        function handleId(id2) {
          if (id2 in cache) {
            return cache[id2];
          }
          ends[id2] = true;
          var dependsOn = [];
          for (var depId in dependencyResolver(id2)) {
            if (depId in ids) {
              dependsOn.push(depId);
            }
          }
          var value;
          if (dependsOn.length === 0) {
            value = loadComponent(id2);
          } else {
            var depsValue = parallel(dependsOn.map(function(depId2) {
              var value2 = handleId(depId2);
              delete ends[depId2];
              return value2;
            }));
            if (series) {
              value = series(depsValue, function() {
                return loadComponent(id2);
              });
            } else {
              loadComponent(id2);
            }
          }
          return cache[id2] = value;
        }
        for (var id in ids) {
          handleId(id);
        }
        var endValues = [];
        for (var endId in ends) {
          endValues.push(cache[endId]);
        }
        return parallel(endValues);
      }
      function hasKeys(obj) {
        for (var key in obj) {
          return true;
        }
        return false;
      }
      function getLoader2(components, load, loaded) {
        var entryMap = createEntryMap(components);
        var resolveAlias = createAliasResolver(entryMap);
        load = load.map(resolveAlias);
        loaded = (loaded || []).map(resolveAlias);
        var loadSet = toSet(load);
        var loadedSet = toSet(loaded);
        load.forEach(addRequirements);
        function addRequirements(id) {
          var entry2 = entryMap[id];
          forEach(entry2 && entry2.require, function(reqId) {
            if (!(reqId in loadedSet)) {
              loadSet[reqId] = true;
              addRequirements(reqId);
            }
          });
        }
        var dependencyResolver = createDependencyResolver(entryMap);
        var loadAdditions = loadSet;
        var newIds;
        while (hasKeys(loadAdditions)) {
          newIds = {};
          for (var loadId in loadAdditions) {
            var entry = entryMap[loadId];
            forEach(entry && entry.modify, function(modId) {
              if (modId in loadedSet) {
                newIds[modId] = true;
              }
            });
          }
          for (var loadedId in loadedSet) {
            if (!(loadedId in loadSet)) {
              for (var depId in dependencyResolver(loadedId)) {
                if (depId in loadSet) {
                  newIds[loadedId] = true;
                  break;
                }
              }
            }
          }
          loadAdditions = newIds;
          for (var newId in loadAdditions) {
            loadSet[newId] = true;
          }
        }
        var loader = {
          getIds: function() {
            var ids = [];
            loader.load(function(id) {
              ids.push(id);
            });
            return ids;
          },
          load: function(loadComponent, chainer) {
            return loadComponentsInOrder(dependencyResolver, loadSet, loadComponent, chainer);
          }
        };
        return loader;
      }
      return getLoader2;
    }();
    if (typeof module !== "undefined") {
      module.exports = getLoader;
    }
  }
});

// node_modules/prismjs/components/index.js
var require_components2 = __commonJS({
  "node_modules/prismjs/components/index.js"(exports, module) {
    var components = require_components();
    var getLoader = require_dependencies();
    var loadedLanguages = /* @__PURE__ */ new Set();
    function loadLanguages(languages) {
      if (languages === void 0) {
        languages = Object.keys(components.languages).filter((l) => l != "meta");
      } else if (!Array.isArray(languages)) {
        languages = [languages];
      }
      const loaded = [...loadedLanguages, ...Object.keys(Prism.languages)];
      getLoader(components, languages, loaded).load((lang) => {
        if (!(lang in components.languages)) {
          if (!loadLanguages.silent) {
            console.warn("Language does not exist: " + lang);
          }
          return;
        }
        const pathToLanguage = "./prism-" + lang;
        delete __require.cache[__require.resolve(pathToLanguage)];
        delete Prism.languages[lang];
        __require(pathToLanguage);
        loadedLanguages.add(lang);
      });
    }
    loadLanguages.silent = false;
    module.exports = loadLanguages;
  }
});
export default require_components2();
//# sourceMappingURL=prismjs_components_.js.map
